/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module generate_rn #(
        parameter SEED = 30'h286b4b9c,
        parameter FAST_CLOCK_DIV = 5'h14
    ) (
        input wire clk,
        input wire rst,
        output reg [31:0] out
    );
    localparam GENERATE_NUMBER_CLOCK_SPEED = FAST_CLOCK_DIV + 1'h1;
    localparam _MP_SIZE_1066858964 = 1'h1;
    localparam _MP_DIV_1066858964 = FAST_CLOCK_DIV;
    localparam _MP_TOP_1066858964 = 1'h0;
    localparam _MP_UP_1066858964 = 1'h1;
    logic [0:0] M_seed_clock_value;
    
    counter #(
        .SIZE(_MP_SIZE_1066858964),
        .DIV(_MP_DIV_1066858964),
        .TOP(_MP_TOP_1066858964),
        .UP(_MP_UP_1066858964)
    ) seed_clock (
        .clk(clk),
        .rst(rst),
        .value(M_seed_clock_value)
    );
    
    
    localparam _MP_SIZE_1441932793 = 1'h1;
    localparam _MP_DIV_1441932793 = GENERATE_NUMBER_CLOCK_SPEED;
    localparam _MP_TOP_1441932793 = 1'h0;
    localparam _MP_UP_1441932793 = 1'h1;
    logic [0:0] M_generate_next_number_clock_value;
    
    counter #(
        .SIZE(_MP_SIZE_1441932793),
        .DIV(_MP_DIV_1441932793),
        .TOP(_MP_TOP_1441932793),
        .UP(_MP_UP_1441932793)
    ) generate_next_number_clock (
        .clk(clk),
        .rst(rst),
        .value(M_generate_next_number_clock_value)
    );
    
    
    localparam _MP_SEED_1259873812 = 33'h19430f418;
    logic M_random_number_next;
    logic [31:0] M_random_number_seed;
    logic [31:0] M_random_number_num;
    
    pn_gen #(
        .SEED(_MP_SEED_1259873812)
    ) random_number (
        .clk(clk),
        .rst(rst),
        .next(M_random_number_next),
        .seed(M_random_number_seed),
        .num(M_random_number_num)
    );
    
    
    localparam _MP_RISE_1307233449 = 1'h1;
    localparam _MP_FALL_1307233449 = 1'h1;
    logic M_edge_detector_next_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1307233449),
        .FALL(_MP_FALL_1307233449)
    ) edge_detector_next (
        .in(M_generate_next_number_clock_value),
        .clk(clk),
        .out(M_edge_detector_next_out)
    );
    
    
    localparam _MP_RISE_1467676833 = 1'h1;
    localparam _MP_FALL_1467676833 = 1'h1;
    logic M_edge_detector_seed_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1467676833),
        .FALL(_MP_FALL_1467676833)
    ) edge_detector_seed (
        .in(M_seed_clock_value),
        .clk(clk),
        .out(M_edge_detector_seed_out)
    );
    
    
    logic [15:0] D_seed_d, D_seed_q = 0;
    logic [31:0] D_randomnumber_d, D_randomnumber_q = 0;
    always @* begin
        D_seed_d = D_seed_q;
        D_randomnumber_d = D_randomnumber_q;
        
        out = 1'h0;
        M_random_number_seed = D_seed_q;
        M_random_number_next = M_edge_detector_next_out;
        if (M_edge_detector_seed_out) begin
            D_seed_d = D_seed_q + 1'h1;
        end
        D_randomnumber_d = M_random_number_num;
        out = D_randomnumber_q;
    end
    
    
    always @(posedge (clk)) begin
        D_seed_q <= D_seed_d;
        D_randomnumber_q <= D_randomnumber_d;
        
    end
endmodule