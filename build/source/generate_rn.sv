/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module generate_rn #(
        parameter SEED = 30'h286b4b9c,
        parameter FAST_CLOCK_DIV = 5'h14
    ) (
        input wire clk,
        input wire rst,
        output reg [31:0] out
    );
    localparam GENERATE_NUMBER_CLOCK_SPEED = FAST_CLOCK_DIV + 1'h1;
    localparam _MP_SIZE_600688210 = 1'h1;
    localparam _MP_DIV_600688210 = FAST_CLOCK_DIV;
    localparam _MP_TOP_600688210 = 1'h0;
    localparam _MP_UP_600688210 = 1'h1;
    logic [0:0] M_seed_clock_value;
    
    counter #(
        .SIZE(_MP_SIZE_600688210),
        .DIV(_MP_DIV_600688210),
        .TOP(_MP_TOP_600688210),
        .UP(_MP_UP_600688210)
    ) seed_clock (
        .clk(clk),
        .rst(rst),
        .value(M_seed_clock_value)
    );
    
    
    localparam _MP_SIZE_296657521 = 1'h1;
    localparam _MP_DIV_296657521 = GENERATE_NUMBER_CLOCK_SPEED;
    localparam _MP_TOP_296657521 = 1'h0;
    localparam _MP_UP_296657521 = 1'h1;
    logic [0:0] M_generate_next_number_clock_value;
    
    counter #(
        .SIZE(_MP_SIZE_296657521),
        .DIV(_MP_DIV_296657521),
        .TOP(_MP_TOP_296657521),
        .UP(_MP_UP_296657521)
    ) generate_next_number_clock (
        .clk(clk),
        .rst(rst),
        .value(M_generate_next_number_clock_value)
    );
    
    
    localparam _MP_SEED_764479521 = 33'h19430f418;
    logic M_random_number_next;
    logic [31:0] M_random_number_seed;
    logic [31:0] M_random_number_num;
    
    pn_gen #(
        .SEED(_MP_SEED_764479521)
    ) random_number (
        .clk(clk),
        .rst(rst),
        .next(M_random_number_next),
        .seed(M_random_number_seed),
        .num(M_random_number_num)
    );
    
    
    localparam _MP_RISE_1432849303 = 1'h1;
    localparam _MP_FALL_1432849303 = 1'h1;
    logic M_edge_detector_next_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1432849303),
        .FALL(_MP_FALL_1432849303)
    ) edge_detector_next (
        .in(M_generate_next_number_clock_value),
        .clk(clk),
        .out(M_edge_detector_next_out)
    );
    
    
    localparam _MP_RISE_794744154 = 1'h1;
    localparam _MP_FALL_794744154 = 1'h1;
    logic M_edge_detector_seed_out;
    
    edge_detector #(
        .RISE(_MP_RISE_794744154),
        .FALL(_MP_FALL_794744154)
    ) edge_detector_seed (
        .in(M_seed_clock_value),
        .clk(clk),
        .out(M_edge_detector_seed_out)
    );
    
    
    logic [15:0] D_seed_d, D_seed_q = 0;
    always @* begin
        D_seed_d = D_seed_q;
        
        out = 1'h0;
        M_random_number_seed = D_seed_q;
        M_random_number_next = M_edge_detector_next_out;
        if (M_edge_detector_seed_out) begin
            D_seed_d = D_seed_q + 1'h1;
        end
        out = M_random_number_num;
    end
    
    
    always @(posedge (clk)) begin
        D_seed_q <= D_seed_d;
        
    end
endmodule